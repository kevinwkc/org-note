* Week 1
** What is Reactive Programming?
- New era of computation need new architecture
  - *Previously*: Managed servers and containers.
  - *Now*: Reactive applications
    + event-driven (React to events)
    + scalable (React to load)
    + resilient (React to failures)
    + responsive (React to usersxs)
- Event-Driven
  - *Traditionally*: Systems are composed of multiple threads, which communicate with shared, synchronized state.
    + Strong coupling, hard to compose.
  - *Now*: Systems are composed from loosely coupled event handlers.
    + Events can be handled asynchronously, without blocking.
- Scalable
    - scale up: using parallelism of multi-core
    - scale out: using multiple server ndoes
  - Important for scalability: Minimize shared mutable state.
  - Important for scale out: Location transparency, resilience.
- Resilient
  - An application is *resilient* if it can recover quickly from failures (software, haredware or connection failures).
  - Typically, resilience cannot be added as an afterthought; it needs to be part of the design from the beginning. Needed:
    - loose coupling
    - strong encapsulation of state
    - pervasive supervisor hierarchies
- Responsive
  An application is *responsive* if it provides rich, real-time interaction with its users even under load and in the presence of failures.

  Responsive applications can be built on an event-driven, scalable, and resilient architecture.

  Still need careful attention to algorithms, system design, back-pressure, and many other details.
- Call-backs
  -  Handling events is often done using call-backs. E.g. using Java observers:
#+begin_src scala
class Counter extends ActionListener {
  private var count = 0
  button.addActionListener(this)
  
  def actionPerformed(e: ActionEvent): Unit = {
    count += 1
  }
}
#+end_src
  - Problems
    - needs shared mutable state (here is =count=)
    - cannot be composed
    - leads quickly to "call-back hell"
- How To Do Better
  - Use fundamental constructions from functional programming to get *composable* event abstractions.
    - Events are first class
    - Events are often represented as messages
    - Handlers of events are also first-class
    - Complex handlers can be composed from primitive ones
** Recap: Functions and Pattern Matching
- Recap: Case Classes
Case classes are Scala's preferred way to define complex data.
- Representation of JSON in Scala
#+begin_src scala
abstract class JSON
case class JSeq  (elems: List[JSON])           extends JSON
case class JObj  (bindings: Map[String, JSON]) extends JSON
case class JNum  (num: Double)                 extends JSON
case class JStr  (str: String)                 extends JSON
case class JBool (b: Boolean)                  extends JSON
case object JNull                              extends JSON
#+end_src
#+begin_src scala
val data = JObj(Map(
  "firstName" -> JStr("John"),
  "lastName" -> JStr("Smith"),
  "address" -> JObj(Map(
    "streetAddress" -> JStr("21 2nd Street"),
    "state" -> JStr("NY"),
    "postalCode" -> JNum(10021)
  )),
  "phoneNumbers" -> JSeq(List(
    JObj(Map(
      "type" -> JStr("home"), "number" -> JStr("212 555-1234")
    )),
    JObj(Map(
      "type" -> JStr("fax"), "number" -> JStr("646 555-4567")
   )) )) ))
#+end_src scala
- Pattern Matching
Here's a method that returns the string representation JSON data:
#+begin_src scala
def show(json: JSON): String = json match {
  case JSeq(elems) =>
    "[" + (elems map show mkString ",") + "]"
  case JObj(bindings) =>
    val assocs = bindings  map {
      case (key, value) => "\"" + key + "\": " + show(value)
    }
    "{" + (assocs mkString ", ") + "}"
  case JNum(num) => num.toString
  case JStr(str) => '\"' + str + '\"'
  case JBool(b)  => b.toString
  case JNull     => "null"
}
#+end_src scala
- Functions Are Objects
In Scala, every concrete type is the type of some class or trait.

The function type is no exception. A type like
#+begin_src scala
JBinding => String
#+end_src
is just a shorthand for
#+begin_src scala
scala.Function1[JBinding, String]
#+end_src
where =scala.Function1= is a trait and =JBinding= and =String= are its type arguments.
- The Function1 Trait
Here's an outline of that =Function1=:
#+begin_src scala
trait Function[-A, +R] {
  def apply(x: A): R
}
#+end_src 
The pattern matching block
#+begin_src scala
{ case (key, value)=> key + ": " + value }
#+end_src
expands to the =Function1= instance
#+begin_src scala
new Function1[JBinding, String] {
  def apply(x: JBinding) = x match {
    case (key, value) => key + ": " + show(value)
  }
}
#+end_src
- Subclassing Functions
One nice aspect of functions being traits is that we can subclass the function type.

For instance, maps are functions from keys to values:
#+begin_src scala
trait Map[Key, Value] extends (Key => Value) ...
#+end_src
Sequences are functions from =int= indices to values:
#+begin_src scala
trait Seq[Elem] extends (Int => Elem)
#+end_src
That's why we can write

=elems(i)=

for sequence (and array) indexing.
- Partial Functions
#+begin_src scala
val f: PartialFunction[String, String] = { case "ping" => "pong"}
f.isDefinedAt("ping")    // true
f.isDefinedAt("pong")    // false
#+end_src
The partial function trait is defined as follows:
#+begin_src scala
trait PartialFunction[-A, +R] extends Function1[-A, +R] {
  def apply(x: A): R
  def isDefinedAt(x: A): R
}
#+end_src
- Partial Function Objects
If the expected type is a =PartialFunction=, the Scala compiler willl expand ={ case "ping" => "pong" }=

as follows:
#+begin_src scala
new PartialFunction[String, String] {
  ...
  def isDefinedAt(x: String) = x match {
    case "ping" => true
    case _ => false
  }
}
#+end_src
Note: =isDefinedAt= will only be determined by the outmost pattern
** Recap: Collections
** Functional Random Generators
*** Other Uses of For-Expressions
Operations of sets, or databases, or options.

*Question:* Are for-expressions tied to collections?

*Answer:* No! All that is required is some interpretation of =map, flatMap= and =withFilter=.

There are many domains outside collections that afford such an interpretation.

Example: random value generators.
*** Random Values
You know about random numbers:
#+begin_src scala
import java.util.Random
val rand = new Random
rand.nextInt()
#+end_src
Question: What is a systematic way to get random values for other domains, such as
  - booleans, strings, pairs and tuples, lists, sets, trees
*** Generators
Let's define a trait =Generator[T]= that generates random values of =type T=:
#+begin_src scala
trait Generator[+T] {
  def generate: T
}
#+end_src scala
Some instances:
#+begin_src scala
val integers = new Generator[int] {
  val rand = new java.util.Random
  def generate = rand.nextInt()
}

val booleans = new Generator[Boolean] {
  def generate = integers.generate > 0
}

val pairs = new Generator[(Int, Int)] {
  def generate = (integers.generate, integers.generate)
}
#+end_src
*** Streamlining It
Can we avoid the =new Generator ...= boilerplate?

Ideally, we would like to write:
#+begin_src scala
val booleans = for (x <- integers) yield x > 0

def pairs[T, U](t: Generator[T], u: Generator[U]) = for {
  x <- t
  y <- u
} yield (x, y)
#+end_src
What does this expand do?
#+begin_src scala
val booleans = integers map (x => x > 0)

def pair[T, U](t: Generator[T], u: Generator[U]) {
  t flatMap (x => u map (y => (x, y)))
#+end_src
Need =map= and =flatMap= for that!
*** Generator with =map= and =flatMap=
Here's a more convenient version of Generator:
#+begin_src scala
trait Generator[+T] {
  self =>       // an alias for "this" to avoid circular reference. Here equal to Generator.this.

  def generate: T

  def map[S](f: T => S): Generator[S] = new Generator[S] {
    def generate = f(self.generate)

  def flatMap[S](f: T => Generator[S]): Generator[S] = new Generator[S] {
    def generate = f(self.generate).generate
  }
}
#+end_src
*** The booleans Generator
What does this definition resolve to?
#+begin_src scala
val booleans = for (x <- integers) yield x > 0

val booleans = integers map { x =. x . 0 }

val booleans = new Generator[Boolean] {
  def generate = (x: Int => x > 0)(integers.generate)
}

val booleans  = new Generator[Boolean] {
  def generate = integers.generate > 0
}
#+end_src
*** The pairs Generator
#+begin_src scala
#+end_src
*** Generator Examples
#+begin_src scala
def single[T](x: T): Generator[T] = new Generator[T] {
  def generate = x
}

def choose(lo: Int, hi: Int): Generator[Int] =
  for (x <- integers) yield lo + x % (hi - io)

def oneOf[T](xs: T*): Generator[T] = 
  for (idx <- choose(0, xs.length)) yield xs(idx)
#+end_src
*** A =List= Generator
A list is either an empty list or a non-empty list.
#+begin_src scala
def lists: Generator{List[Int]] = for {
  isEmpty <- booleans
  list <- if (isEmpty) emptyLists else nonEmptyLists
} yield list

def emptyLists = single(Nil)

def nonEmptyLists = for {
  head <- integers
  tail <- lists
} yield head :: tail
#+end_src
*** Tree Generator
#+begin_src scala
#+end_src scala
*** Application: Random Testing
You know about unit tests:
- Come up with some test inputs to program functions and a /postcondition/.
- The postcondition is a property of the expected result
- Verify that the program satisfies the postcondition.
*Question:* Can we do without the test inputs?
Yes, by generating random test inputs.
*** Random Test Function
Using generators, we can write a random test function:
#+begin_src scala
def test[T](g: Generator[T], numTimes: Int = 100)
  (test: T => Boolean): Unit = {
 for (i <- 0 until numTimes) {
   val value = g.generate
   assert(test(value), "test failed for "+value)
  }
  println("passed"+numTimes+" tests")
}
#+end_src scala
*** ScalaCheck
Shift in viewpoint: Instead of writing tests, write *properties* that are assumed to hold.

This idea is implemented in the =ScalaCheck= tool.
#+begin_src scala
forAll { (l1: List[Int], l2: List[Int]) =>
  l1.size + l2.size == (l1 ++ l2).size
}
#+end_src scala
It can be used either stand-alone or as part of ScalaTest.
[[https://hackage.haskell.org/package/QuickCheck][QuickCheck]]

** Monads
Data structures with =map= and =flatMap= seem to be quite common.

In fact there's a name that describes this class of a data structures together with some algebraia laws that they should have.

They are called *monads*.
*** What is a Monad?
A monad M is a parametric type =M[T]= with two operations, =flatMap= and =unit=, that have to satisfy some laws.
#+begin_src scala
trait M[T] {
  def flatMap[U](f: T => M[U]): M[U]
}

def unit[T](x: T): M[T]
#+end_src
In the literature, =flatMap= is more commonly called =bind=.
*** Example of Monads
- =List= is a monad with =unit(x) = List(x)=
- =Set= is monad with =unit(x) = Set(x)=
- =Option= is a monad with =uint(x) = Some(x)=
- =Generator= is a monad with =unit(x) = single(x)=
=flatMap= is an operation on each of these types, whereas =unit= in Scala is different for each monad.
*** Monads and map
=map= can be defined for every monad as a combination of =flatMap= and =uint=:
#+begin_src scala
m map f == m flatMap (x => unit(f(x)))
        == m flatMap (f andThen unit)
#+end_src
*** Monad Laws
To qualify as a monad, a type has to satisfy three laws:

*Associativity:*
#+begin_src scala
m flatMap f flatMap g == m flatMap (x => f(x) flatMap g)
#+end_src
*Left unit*
#+begin_src scala
unit(x) flatMap f == f(x)
#+end_src
*Right unit*
#+begin_src scala
m flatMap unit == m
#+end_src
*** Checking Monad Laws
Let's check the monad laws for =Optbion=.

Here's =flatMap= for =Option=.
#+begin_src scala
abstract class Option[+T] {
  def flatMap[U](f: T=> Option[U]): Option[U] = this match {
    case Some(x) => f(x)
    case None => None
  }
}
#+end_src
*** Checking the Left Unit Law
#+begin_src scala
   Some(x) flatMap f
== Some(x) match {
     case Some(x) => f(x)
     case None => None
   }
== f(x)
#+end_src
*** Chekcing the Right Unit Law
#+begin_src scala
   opt flatMap Some
== opt match {
     case Some(x) => Some(x)
     case None => None
   }
== opt
#+end_src
*** Checking the Associative Law
#+begin_src scala
opt flatMap f flatMap g
#+end_src
*** Significance of the Laws for For-Expressions
We have seen that monad-typed expressions are typically written as for expressions.

What is the significance of the laws with respect to this?

1. Associativity says essentially that one can "inline" nested for expressions:
#+begin_src scala
   for (y <- for (x <- m; y <- f(x)) yield y
        z <- g(y)) yield z
== for (x <- m;
        y <- f(x)
        z <- g(y)) yield z
#+end_src
2. Right unit says:
#+begin_src scala
   for (x <- m) yield x
== m
#+end_src
3. Left unit does not have an analogue for for-expression.
*** Another type: =Try=
In the later parts of this course we will need a type named =Try=.

=Try= resembles =Option=, but instead of =Some/None= there is a =Success= case with a value and a =Failure= case that contains an exception:
#+begin_src scala
abstract class Try[+T]
case class Success[T](x: T}       extends Try[T]
case class Failure(ex: Exception) extends Try[Noting]
#+end_src
=Try= is used to pass results of computations that can fail with an exception between threads and computers.
*** Creating a Try
You can wrap up an arbitrary computation in a Try.
#+begin_src scala
Try(expr)    // gives Success(someValue) or Failure(someException) 
#+end_src
Here's an implementation of =Try=:
#+begin_src scala
object Try {
  def apply[T](expr: => T): Try[T] =
    try Success(expr)
    catch {
      case NonFatal(ex) => Failure(ex)
    }
#+end_src
*** Composing =Try=
Just like with =option=, =Try=-valued computations can be composed in for-expressions.
#+begin_src scala
for {
  x <- computeX
  y <- computeY
} yield f(x, y)
#+end_src
If =computeX= and =computeY= succeed with results =Success(x)= and =Success(y)=, this will return =Success(f(x, y)).

If either computation fails with an exception =ex=, this will return =Failure(ex)=.
*** Definition of =flatMap= and =map= on =Try=
#+begin_src scala
abstract class Try[T] {
  def flatMap[U](f: T => Try[U]): Try[U] = this match {
    case Success(x) => try f(x) catch { case NonFatal(ex) => Failure(ex) }
    case fail: Failure => fail
  }

  def map[U](f: T => U): Try[U] = this match {
    case Success(x) => Try(f(x))
    case fail: Failure => fail
  }}
#+end_src 
So, for a =Try= value =t=,
#+begin_src scala
t map f == t flatMap (x => Try(f(x)))
        == t flatMap (f andThen Try)
#+end_src
