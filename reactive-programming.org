* Week 1
** What is Reactive Programming?
- New era of computation need new architecture
  - *Previously*: Managed servers and containers.
  - *Now*: Reactive applications
    + event-driven (React to events)
    + scalable (React to load)
    + resilient (React to failures)
    + responsive (React to usersxs)
- Event-Driven
  - *Traditionally*: Systems are composed of multiple threads, which communicate with shared, synchronized state.
    + Strong coupling, hard to compose.
  - *Now*: Systems are composed from loosely coupled event handlers.
    + Events can be handled asynchronously, without blocking.
- Scalable
    - scale up: using parallelism of multi-core
    - scale out: using multiple server ndoes
  - Important for scalability: Minimize shared mutable state.
  - Important for scale out: Location transparency, resilience.
- Resilient
  - An application is *resilient* if it can recover quickly from failures (software, haredware or connection failures).
  - Typically, resilience cannot be added as an afterthought; it needs to be part of the design from the beginning. Needed:
    - loose coupling
    - strong encapsulation of state
    - pervasive supervisor hierarchies
- Responsive
  An application is *responsive* if it provides rich, real-time interaction with its users even under load and in the presence of failures.

  Responsive applications can be built on an event-driven, scalable, and resilient architecture.

  Still need careful attention to algorithms, system design, back-pressure, and many other details.
- Call-backs
  -  Handling events is often done using call-backs. E.g. using Java observers:
#+begin_src scala
class Counter extends ActionListener {
  private var count = 0
  button.addActionListener(this)
  
  def actionPerformed(e: ActionEvent): Unit = {
    count += 1
  }
}
#+end_src
  - Problems
    - needs shared mutable state (here is =count=)
    - cannot be composed
    - leads quickly to "call-back hell"
- How To Do Better
  - Use fundamental constructions from functional programming to get *composable* event abstractions.
    - Events are first class
    - Events are often represented as messages
    - Handlers of events are also first-class
    - Complex handlers can be composed from primitive ones
** Recap: Functions and Pattern Matching
- Recap: Case Classes
Case classes are Scala's preferred way to define complex data.
- Representation of JSON in Scala
#+begin_src scala
abstract class JSON
case class JSeq  (elems: List[JSON])           extends JSON
case class JObj  (bindings: Map[String, JSON]) extends JSON
case class JNum  (num: Double)                 extends JSON
case class JStr  (str: String)                 extends JSON
case class JBool (b: Boolean)                  extends JSON
case object JNull                              extends JSON
#+end_src
#+begin_src scala
val data = JObj(Map(
  "firstName" -> JStr("John"),
  "lastName" -> JStr("Smith"),
  "address" -> JObj(Map(
    "streetAddress" -> JStr("21 2nd Street"),
    "state" -> JStr("NY"),
    "postalCode" -> JNum(10021)
  )),
  "phoneNumbers" -> JSeq(List(
    JObj(Map(
      "type" -> JStr("home"), "number" -> JStr("212 555-1234")
    )),
    JObj(Map(
      "type" -> JStr("fax"), "number" -> JStr("646 555-4567")
   )) )) ))
#+end_src scala
- Pattern Matching
Here's a method that returns the string representation JSON data:
#+begin_src scala
def show(json: JSON): String = json match {
  case JSeq(elems) =>
    "[" + (elems map show mkString ",") + "]"
  case JObj(bindings) =>
    val assocs = bindings  map {
      case (key, value) => "\"" + key + "\": " + show(value)
    }
    "{" + (assocs mkString ", ") + "}"
  case JNum(num) => num.toString
  case JStr(str) => '\"' + str + '\"'
  case JBool(b)  => b.toString
  case JNull     => "null"
}
#+end_src scala
- Functions Are Objects
In Scala, every concrete type is the type of some class or trait.

The function type is no exception. A type like

src_scala{JBinding => String}

is just a shorthand for

src_scala{scala.Function1[JBinding, String]}

where =scala.Function1= is a trait and =JBinding= and =String= are its type arguments.
- The Function1 Trait
Here's an outline of that =Function1=:
#+begin_src scala
trait Function[-A, +R] {
  def apply(x: A): R
}
#+end_src 
The pattern matching block
#+begin_src scala
{ case (key, value)=> key + ": " + value }
#+end_src
expands to the =Function1= instance
#+begin_src scala
new Function1[JBinding, String] {
  def apply(x: JBinding) = x match {
    case (key, value) => key + ": " + show(value)
  }
}
#+end_src
- Subclassing Functions
One nice aspect of functions being traits is that we can subclass the function type.

For instance, maps are functions from keys to values:

src_scala{trait Map[Key, Value] extends (Key => Value) ...}

Sequences are functions from =int= indices to values:

src_scala{trait Seq[Elem] extends Int => Elem}

That's why we can write

=elems(i)=

for sequence (and array) indexing.
- Partial Functions
#+begin_src scala
val f: PartialFunction[String, String] = { case "ping" => "pong"}
f.isDefinedAt("ping")    // true
f.isDefinedAt("pong")    // false
#+end_src
The partial function trait is defined as follows:
#+begin_src scala
trait PartialFunction[-A, +R] extends Function1[-A, +R] {
  def apply(x: A): R
  def isDefinedAt(x: A): R
}
#+end_src
- Partial Function Objects
If the expected type is a =PartialFunction=, the Scala compiler willl expand src_scala{{ case "ping" => "pong" }}

as follows:
#+begin_src scala
new PartialFunction[String, String] {
  ...
  def isDefinedAt(x: String) = x match {
    case "ping" => true
    case _ => false
  }
}
#+end_src
Note: =isDefinedAt= will only be determined by the outmost pattern
