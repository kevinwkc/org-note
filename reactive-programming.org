* Week 1
** What is Reactive Programming?
- New era of computation need new architecture
  - *Previously*: Managed servers and containers.
  - *Now*: Reactive applications
    + event-driven (React to events)
    + scalable (React to load)
    + resilient (React to failures)
    + responsive (React to usersxs)
- Event-Driven
  - *Traditionally*: Systems are composed of multiple threads, which communicate with shared, synchronized state.
    + Strong coupling, hard to compose.
  - *Now*: Systems are composed from loosely coupled event handlers.
    + Events can be handled asynchronously, without blocking.
- Scalable
    - scale up: using parallelism of multi-core
    - scale out: using multiple server ndoes
  - Important for scalability: Minimize shared mutable state.
  - Important for scale out: Location transparency, resilience.
- Resilient
  - An application is *resilient* if it can recover quickly from failures (software, haredware or connection failures).
  - Typically, resilience cannot be added as an afterthought; it needs to be part of the design from the beginning. Needed:
    - loose coupling
    - strong encapsulation of state
    - pervasive supervisor hierarchies
- Responsive
  An application is *responsive* if it provides rich, real-time interaction with its users even under load and in the presence of failures.

  Responsive applications can be built on an event-driven, scalable, and resilient architecture.

  Still need careful attention to algorithms, system design, back-pressure, and many other details.
- Call-backs
  -  Handling events is often done using call-backs. E.g. using Java observers:
#+begin_src scala
class Counter extends ActionListener {
  private var count = 0
  button.addActionListener(this)
  
  def actionPerformed(e: ActionEvent): Unit = {
    count += 1
  }
}
#+end_src
  - Problems
    - needs shared mutable state (here is =count=)
    - cannot be composed
    - leads quickly to "call-back hell"
- How To Do Better
  - Use fundamental constructions from functional programming to get *composable* event abstractions.
    - Events are first class
    - Events are often represented as messages
    - Handlers of events are also first-class
    - Complex handlers can be composed from primitive ones
** Recap: Functions and Pattern Matching
- Recap: Case Classes
Case classes are Scala's preferred way to define complex data.
- Representation of JSON in Scala
#+begin_src scala
abstract class JSON
case class JSeq  (elems: List[JSON])           extends JSON
case class JObj  (bindings: Map[String, JSON]) extends JSON
case class JNum  (num: Double)                 extends JSON
case class JStr  (str: String)                 extends JSON
case class JBool (b: Boolean)                  extends JSON
case object JNull                              extends JSON
#+end_src
#+begin_src scala
val data = JObj(Map(
  "firstName" -> JStr("John"),
  "lastName" -> JStr("Smith"),
  "address" -> JObj(Map(
    "streetAddress" -> JStr("21 2nd Street"),
    "state" -> JStr("NY"),
    "postalCode" -> JNum(10021)
  )),
  "phoneNumbers" -> JSeq(List(
    JObj(Map(
      "type" -> JStr("home"), "number" -> JStr("212 555-1234")
    )),
    JObj(Map(
      "type" -> JStr("fax"), "number" -> JStr("646 555-4567")
   )) )) ))
#+end_src scala
- Pattern Matching
Here's a method that returns the string representation JSON data:
#+begin_src scala
def show(json: JSON): String = json match {
  case JSeq(elems) =>
    "[" + (elems map show mkString ",") + "]"
  case JObj(bindings) =>
    val assocs = bindings  map {
      case (key, value) => "\"" + key + "\": " + show(value)
    }
    "{" + (assocs mkString ", ") + "}"
  case JNum(num) => num.toString
  case JStr(str) => '\"' + str + '\"'
  case JBool(b)  => b.toString
  case JNull     => "null"
}
#+end_src scala
- Functions Are Objects
In Scala, every concrete type is the type of some class or trait.

The function type is no exception. A type like
#+begin_src scala
JBinding => String
#+end_src
is just a shorthand for
#+begin_src scala
scala.Function1[JBinding, String]
#+end_src
where =scala.Function1= is a trait and =JBinding= and =String= are its type arguments.
- The Function1 Trait
Here's an outline of that =Function1=:
#+begin_src scala
trait Function[-A, +R] {
  def apply(x: A): R
}
#+end_src 
The pattern matching block
#+begin_src scala
{ case (key, value)=> key + ": " + value }
#+end_src
expands to the =Function1= instance
#+begin_src scala
new Function1[JBinding, String] {
  def apply(x: JBinding) = x match {
    case (key, value) => key + ": " + show(value)
  }
}
#+end_src
- Subclassing Functions
One nice aspect of functions being traits is that we can subclass the function type.

For instance, maps are functions from keys to values:
#+begin_src scala
trait Map[Key, Value] extends (Key => Value) ...
#+end_src
Sequences are functions from =int= indices to values:
#+begin_src scala
trait Seq[Elem] extends (Int => Elem)
#+end_src
That's why we can write

=elems(i)=

for sequence (and array) indexing.
- Partial Functions
#+begin_src scala
val f: PartialFunction[String, String] = { case "ping" => "pong"}
f.isDefinedAt("ping")    // true
f.isDefinedAt("pong")    // false
#+end_src
The partial function trait is defined as follows:
#+begin_src scala
trait PartialFunction[-A, +R] extends Function1[-A, +R] {
  def apply(x: A): R
  def isDefinedAt(x: A): R
}
#+end_src
- Partial Function Objects
If the expected type is a =PartialFunction=, the Scala compiler willl expand ={ case "ping" => "pong" }=

as follows:
#+begin_src scala
new PartialFunction[String, String] {
  ...
  def isDefinedAt(x: String) = x match {
    case "ping" => true
    case _ => false
  }
}
#+end_src
Note: =isDefinedAt= will only be determined by the outmost pattern
** Recap: Collections
** Functional Random Generators
*** Other Uses of For-Expressions
Operations of sets, or databases, or options.

*Question:* Are for-expressions tied to collections?

*Answer:* No! All that is required is some interpretation of =map, flatMap= and =withFilter=.

There are many domains outside collections that afford such an interpretation.

Example: random value generators.
*** Random Values
You know about random numbers:
#+begin_src scala
import java.util.Random
val rand = new Random
rand.nextInt()
#+end_src
Question: What is a systematic way to get random values for other domains, such as
  - booleans, strings, pairs and tuples, lists, sets, trees
*** Generators
Let's define a trait =Generator[T]= that generates random values of =type T=:
#+begin_src scala
trait Generator[+T] {
  def generate: T
}
#+end_src scala
Some instances:
#+begin_src scala
val integers = new Generator[int] {
  val rand = new java.util.Random
  def generate = rand.nextInt()
}

val booleans = new Generator[Boolean] {
  def generate = integers.generate > 0
}

val pairs = new Generator[(Int, Int)] {
  def generate = (integers.generate, integers.generate)
}
#+end_src
*** Streamlining It
Can we avoid the =new Generator ...= boilerplate?

Ideally, we would like to write:
#+begin_src scala
val booleans = for (x <- integers) yield x > 0

def pairs[T, U](t: Generator[T], u: Generator[U]) = for {
  x <- t
  y <- u
} yield (x, y)
#+end_src
What does this expand do?
#+begin_src scala
val booleans = integers map (x => x > 0)

def pair[T, U](t: Generator[T], u: Generator[U]) {
  t flatMap (x => u map (y => (x, y)))
#+end_src
Need =map= and =flatMap= for that!
*** Generator with =map= and =flatMap=
Here's a more convenient version of Generator:
#+begin_src scala
trait Generator[+T] {
  self =>       // an alias for "this" to avoid circular reference. Here equal to Generator.this.

  def generate: T

  def map[S](f: T => S): Generator[S] = new Generator[S] {
    def generate = f(self.generate)

  def flatMap[S](f: T => Generator[S]): Generator[S] = new Generator[S] {
    def generate = f(self.generate).generate
  }
}
#+end_src
*** The booleans Generator
What does this definition resolve to?
#+begin_src scala
val booleans = for (x <- integers) yield x > 0

val booleans = integers map { x =. x . 0 }

val booleans = new Generator[Boolean] {
  def generate = (x: Int => x > 0)(integers.generate)
}

val booleans  = new Generator[Boolean] {
  def generate = integers.generate > 0
}
#+end_src
*** The pairs Generator
#+begin_src scala
#+end_src
*** Generator Examples
#+begin_src scala
def single[T](x: T): Generator[T] = new Generator[T] {
  def generate = x
}

def choose(lo: Int, hi: Int): Generator[Int] =
  for (x <- integers) yield lo + x % (hi - io)

def oneOf[T](xs: T*): Generator[T] = 
  for (idx <- choose(0, xs.length)) yield xs(idx)
#+end_src
*** A =List= Generator
A list is either an empty list or a non-empty list.
#+begin_src scala
def lists: Generator{List[Int]] = for {
  isEmpty <- booleans
  list <- if (isEmpty) emptyLists else nonEmptyLists
} yield list

def emptyLists = single(Nil)

def nonEmptyLists = for {
  head <- integers
  tail <- lists
} yield head :: tail
#+end_src
*** Tree Generator
#+begin_src scala
#+end_src scala
*** Application: Random Testing
You know about unit tests:
- Come up with some test inputs to program functions and a /postcondition/.
- The postcondition is a property of the expected result
- Verify that the program satisfies the postcondition.
*Question:* Can we do without the test inputs?
Yes, by generating random test inputs.
*** Random Test Function
Using generators, we can write a random test function:
#+begin_src scala
def test[T](g: Generator[T], numTimes: Int = 100)
  (test: T => Boolean): Unit = {
 for (i <- 0 until numTimes) {
   val value = g.generate
   assert(test(value), "test failed for "+value)
  }
  println("passed"+numTimes+" tests")
}
#+end_src scala
*** ScalaCheck
Shift in viewpoint: Instead of writing tests, write *properties* that are assumed to hold.

This idea is implemented in the =ScalaCheck= tool.
#+begin_src scala
forAll { (l1: List[Int], l2: List[Int]) =>
  l1.size + l2.size == (l1 ++ l2).size
}
#+end_src scala
It can be used either stand-alone or as part of ScalaTest.
[[https://hackage.haskell.org/package/QuickCheck][QuickCheck]]

** Monads
Data structures with =map= and =flatMap= seem to be quite common.

In fact there's a name that describes this class of a data structures together with some algebraia laws that they should have.

They are called *monads*.
*** What is a Monad?
A monad M is a parametric type =M[T]= with two operations, =flatMap= and =unit=, that have to satisfy some laws.
#+begin_src scala
trait M[T] {
  def flatMap[U](f: T => M[U]): M[U]
}

def unit[T](x: T): M[T]
#+end_src
In the literature, =flatMap= is more commonly called =bind=.
*** Example of Monads
- =List= is a monad with =unit(x) = List(x)=
- =Set= is monad with =unit(x) = Set(x)=
- =Option= is a monad with =uint(x) = Some(x)=
- =Generator= is a monad with =unit(x) = single(x)=
=flatMap= is an operation on each of these types, whereas =unit= in Scala is different for each monad.
*** Monads and map
=map= can be defined for every monad as a combination of =flatMap= and =uint=:
#+begin_src scala
m map f == m flatMap (x => unit(f(x)))
        == m flatMap (f andThen unit)
#+end_src
*** Monad Laws
To qualify as a monad, a type has to satisfy three laws:

*Associativity:*
#+begin_src scala
m flatMap f flatMap g == m flatMap (x => f(x) flatMap g)
#+end_src
*Left unit*
#+begin_src scala
unit(x) flatMap f == f(x)
#+end_src
*Right unit*
#+begin_src scala
m flatMap unit == m
#+end_src
*** Checking Monad Laws
Let's check the monad laws for =Optbion=.

Here's =flatMap= for =Option=.
#+begin_src scala
abstract class Option[+T] {
  def flatMap[U](f: T=> Option[U]): Option[U] = this match {
    case Some(x) => f(x)
    case None => None
  }
}
#+end_src
*** Checking the Left Unit Law
#+begin_src scala
   Some(x) flatMap f
== Some(x) match {
     case Some(x) => f(x)
     case None => None
   }
== f(x)
#+end_src
*** Chekcing the Right Unit Law
#+begin_src scala
   opt flatMap Some
== opt match {
     case Some(x) => Some(x)
     case None => None
   }
== opt
#+end_src
*** Checking the Associative Law
#+begin_src scala
opt flatMap f flatMap g
#+end_src
*** Significance of the Laws for For-Expressions
We have seen that monad-typed expressions are typically written as for expressions.

What is the significance of the laws with respect to this?

1.Associativity says essentially that one can "inline" nested for expressions:
#+begin_src scala
   for (y <- for (x <- m; y <- f(x)) yield y
        z <- g(y)) yield z
== for (x <- m;
        y <- f(x)
        z <- g(y)) yield z
#+end_src
2.Right unit says:
#+begin_src scala
   for (x <- m) yield x
== m
#+end_src
3.Left unit does not have an analogue for for-expression.
*** Another type: =Try=
In the later parts of this course we will need a type named =Try=.

=Try= resembles =Option=, but instead of =Some/None= there is a =Success= case with a value and a =Failure= case that contains an exception:
#+begin_src scala
abstract class Try[+T]
case class Success[T](x: T}       extends Try[T]
case class Failure(ex: Exception) extends Try[Noting]
#+end_src
=Try= is used to pass results of computations that can fail with an exception between threads and computers.
*** Creating a Try
You can wrap up an arbitrary computation in a Try.
#+begin_src scala
Try(expr)    // gives Success(someValue) or Failure(someException) 
#+end_src
Here's an implementation of =Try=:
#+begin_src scala
object Try {
  def apply[T](expr: => T): Try[T] =
    try Success(expr)
    catch {
      case NonFatal(ex) => Failure(ex)
    }
#+end_src
*** Composing =Try=
Just like with =option=, =Try=-valued computations can be composed in for-expressions.
#+begin_src scala
for {
  x <- computeX
  y <- computeY
} yield f(x, y)
#+end_src
If =computeX= and =computeY= succeed with results =Success(x)= and =Success(y)=, this will return =Success(f(x, y)).

If either computation fails with an exception =ex=, this will return =Failure(ex)=.
*** Definition of =flatMap= and =map= on =Try=
#+begin_src scala
abstract class Try[T] {
  def flatMap[U](f: T => Try[U]): Try[U] = this match {
    case Success(x) => try f(x) catch { case NonFatal(ex) => Failure(ex) }
    case fail: Failure => fail
  }

  def map[U](f: T => U): Try[U] = this match {
    case Success(x) => Try(f(x))
    case fail: Failure => fail
  }}
#+end_src 
So, for a =Try= value =t=,
#+begin_src scala
t map f == t flatMap (x => Try(f(x)))
        == t flatMap (f andThen Try)
#+end_src
*** Is =Try= a Monad?
It turns out the left unit law fails.
#+begin_src scala
Try(expr) flatMap f != f(expr)
#+end_src
Indeed the left-hand side will never raise a non-fatal exception whereas the right-hand side will raise any exception thrown by =expr= of =f=.

Hence, =Try= trades one monad law for another law which is more useful in this context:
#+begin_center
/An expression composed from 'Try', 'map', 'flatMap' will never throw a non-fatal exception./
#+end_center
Call this the "bullet-proof" principle.
*** Conclusion
Many of the types defining =flatMap= are monads. (If they also define =withFilter=, they are called "monads with zero").

The three monad laws give useful guidance in the design of library APIs.
* Week 2
** Functions and State
*** Observation of Subsititution
Rewriting can be done anywhere in a term, and all rewritings which terminate lead to the same solution.

This is an important result of the \lambda -calculus, the theory behind functional programming.
*** Stateful Objects
One normally describes the world as a set of objects, some of which have state that *changes* over the course of time.

An object *has a state* if its behavior is influenced by its history.
*** Implementation of State
Every form of mutable state is constructed from variables.

A variable definition is written like a value definition, but with the keyword =var= in place of =val=:
#+begin_src scala
var x: String = "abc"
var count = 111

x = "hi"
count = count + 1
#+end_src
*** State in Objects
In practice, objects with state are usually represented by objects that have some variable members.
#+begin_src scala
// Example: Here is a class modeling a bank account.
class BankAccoount {
  private var balance = 0
  def deposit(amount: Int): Unit = {
    if (amount > 0) balance = balance + amount
  }
  def withdraw(amount: Int): Int =
    if (0 < amount && amount <= balance) {
      balance = balance - amount
      balance
    } else throw new Error("insufficient funds")
}
#+end_src
The class =BankAccount= defines a variable =balance= that contains the current balance of the account.

Note that =balance= is private in the =BankAccount= class, it therefore cannot be accessed from outside the class.

To create bank accounts, we use the usual notation for object creation:
#+begin_src scala
val account = new BankAccount
#+end_src
*** Statefulness and Variables
** Identity and Change
#+begin_src scala
val x = E; val y = E
val x = E; val y = x   // y == x == E
#+end_src
*referential transparency*
*** Operational Equivalence
The precise meaning of "being the same" is defined by the property of *operational equivalence*.

In a somewhat informal way, this property is stated as follows.

Suppose we have two definitions =x= and =y=.

=x= and =y= are operationally equivalent if *no possible test* can distinguish between them.
*** Testing Operational Equivalence
f(x, y) == f(x, x)
** Loops
*** Definition of =while=
The function =WHILE= can be defined as follows:
#+begin_src scala
def WHILE(condition: => Boolean)(command: => Unit): Unit =
  if (condition) {
    command
    WHILE(condition)(command)
  }
  else ()
#+end_src
*Note:* The condition and the command must be passed by name so that they're reevaluated in each iteration.

*Note:* =WHILE= is tail recursive, so it can operate with a constant stack size.
*** Translation of For-Loops
For-loops translate similarly to for-expressions, but using the =foreach= combinator instead of =map= and =flatMap=.

=foreach= is defined on collections with element of type =T= as follows:
#+begin_src scala
def foreach(f: T => Unit): Unit = ...
#+end_src
** Extended Example: Discrete Event Simulation
Here's an example that shows how assignments and higher-order functions can be combined in interesting ways.

We will construct a digital circuit simulator.

The simulator is based on a general framework for discrete event simulation.
** Imperative Event Handling: The Observer Pattern
The Observer Pattern is widely use when views need to react to changes in a model.

Variants of it are also called
- publish/subscribe
- model/view/controller (MVC)

+------+  publish  +-------+
|      |<----------+       |
| view |  subsribe | model |
|      +---------->+       |
+------+           +-------+
#+begin_src scala
trait Publisher {
  private var subscribers: Set[Subscriber] = Set()

  def subscribe(subscriber: Subscriber): Unit =
    subscribers += subscriber
  
  def unsubscribe(subscriber: Subscriber): Unit =
    subscribers -= subscriber

  def publish(): Unit =
    subscribers.foreach(_.handler(this))
}

trait Subscriber {
  def handler(pub: Publisher)
}
#+end_src
*** Observer Pattern, The Bad
- Forces imperative style, since handlers are Unit-typed
- Many moving parts that need to be co-ordinated
- Concurrency makes things more complicated
- Views are still tightly bound to one state; view update happens immediately
To quantify (Adobe presentation from 2008)
- 1/3 of the code in Adobe's desktop applications is devoted to event handling
- 1/2 of the bugs are found in this code

** Functional Reactive Programming
*** What is FRP?
Reactive programming is about reacting to sequences of /events/ that happen in /time/.

Functional view: Aggregate an event sequence into a /signal/.
- A signal is a value that changes over time
- It's represented as a function from time to the value domain
- Instead of propagating updates to mutable state, we define new signals in terms of existing ones
*** Example: Mouse Positions
- Event-based view:
Whenever the mouse moves, an event
#+begin_src scala
MouseMoved(toPos: Position)
#+end_src
is fired.
- FRP view:
A singal,
#+begin_src scala
mousePosition: Signal[Position]
#+end_src
which at any point in time represents the current mouse position.
*** Origins of FRP
FRP started in 1997 with the papter /Functional Reactive Animation/ by Conal Elliott and Paul Hudak and the =Fran= library.

There have been many FRP systems since, both standalone languages and embedded libraries.

Some examples are: Flapjax, Elm, Bacon.js, React4J.

Event streaming dataflow programming systems such as Rx, are related but the term FRP is not commonly used for them.

We will introduce FRP by means of a minimal class, =frp.Signal= whose implementation is explained at the end of this module.

=frp.Signal= is modelled after =Scala.react=, which is described in the papter /Deprecating the Observer Pattern/.
*** Fundamental Signal Operations
There are two fundamental operations over signals:
1. Obtain the value of signal at the current time. In our library this is expressed by () application.
#+begin_src scala
mousePosition()    // the current mouse position
#+end_src
2. Define a signal in terms of other signals. In our library, this is expressed by the Signal constructor.
#+begin_src scala
def inReactangle(LL: Position, UR: Position): Signal[Boolean] =
  Signal {
    val pos = mousePosition()
    LL <= pos && pos <= UR
}
#+end_src
*** Constant Signals
The Signal(...) syntax can also be used to define a signal that has always the same value:
#+begin_src scala
val sig = Signal(3)    // the signal that is always 3.
#+end_src
*** Time-Varying Signals
How do we define a signal that varies in time?
- We can use externally defined signals, such as =mousePosition= and =map= over them.
- Or we can use a Var.
*** Variable Signals
Value of type =Signal= are immutable.

But our library also defines a subclass =Var= of =Signal= for signals that can be changed.

=Var= provides an "update" operation, which allows to redefine the value of a signal from the current time on.
#+begin_src scala
val sig = Var(3)
sig.update(5)    // the same as sig() = 5, since in scala f(E_1,...,E_n) = E == f.update(E_1,...,E_n,E)
#+end_src
*** Signals and Variables
Signals of type =Var= look a bit like mutable variables, where =sig()= is dereferencing, and =sig() = newValue= is update.

But there's a crucial difference:
#+begin_src scala
/* mutable var      signal var */
a = 2               a() = 2
l = 2*a             l() = 2*a()
a = a + 1           a()
l = 2 * a
#+end_src
** A Simple FRP Implementation
*** Summary: The Signal API
#+begin_src scala
class Signal[T](expr: => T) {
  def apply(): T = ???
}

object Signal {
  def applay[T](expr: => T) = new Signal(expr)
}
#+end_src
*** Summary: The Var API
#+begin_src scala
class Var[T](expr: =>  T) extends Signal[T](expr) {
  override def update(expr: => T): Unit = super.update(expr)
}

object Var {
  def apply[T](expr: => T) = new Var(expr)
}
#+end_src
*** Implementation Idea
Each signal maintains
- its current value
- the current expression that defines the signal value
- a set of /observers/: the other signals that depend on its value
Then, if the signal changes, all observers need to be re-evaluated.
*** Dependency Maintenance
- When evaluating a signal-valued expression, need to know which signal caller gets defined or updated by the expression
- if we know that, then executing a =sig()= means adding =caller= to the =observers= of =sig=.
- When signal =sig='s value changes, all previously observing signals are re-evaluated and the set =sig.observer= is cleared.
- Re-evaluation will re-enter a calling signal =caller= in =sig.observers=, as long as =caller='s value still depends on =sig=
*** Who's Calling?
One simple(simplistic?) way to do this is to maintain a global data structure referring to the current caller. (we will discuss and refine this later).

That data structure is accessed in a stack-like fashion because one evaluation of a signal might trigger others.
*** Stackable Variables
#+begin_src scala
class StackableVariable[T](init: T) {
  private var values: List[T] = List(init)
  def value: T = values.head
  def withValue[R](newValue: T)(op: => R): R = {
    values = newValue :: values
    try op finally values = values.tail
  }
}
#+end_src
You access it like this
#+begin_src scala
val caller = new StackableVar(initalSig)
caller.withValue(otherSig) {...}
... caller.value ...
#+end_src
*** Set Up in Object Signal
We also evaluate signal expressions at the top-level when there is no other signal that's defined or updated.

We use the "sentinel" object =NoSignal= as the =caller= for these expressions.

Together:
#+begin_src scala
object NoSignal extends Signal[Noting](???) {
  override def computeValue() = ()
}

object Signal {
  private val caller = new StackableVariable[Signal[_]](NoSiganl)
  def apply[T](expr: => T) = new Signal(expr)
}
#+end_src
*** The Signal Class
#+begin_src scala
class Signal[T](expr: => T) {
  import SIgnal._
  private var myExpr: () => T = _
  private var myValue: T = _
  private var observers: Set[Signal[_]] = Set()
  update(expr)

  protected def update(expr: => T): Unit = {
    myExpr = () => expr
    computeValue
  }

  protected def computeValue(): Unit = {
    myValue = caller.withValue(this)(myExpr())
    if (myValue != newValue) {
      myValue = newValue
      val obs = observers
      observers = Set()
      obs.foreach(_.computeValue())
    }
  }

  def apply() = {
    observers += caller.value
    assert(!caller.value.observers.contain(this), "cyclic signal definition")
    myValue
  }
}
#+end_src
*** Discussion
Use global state

One problem: use multiple signal expressions in parallel
*** Thread-Local State
- Thread-local state means that each thread accesses a separate copy of a variable
- It is supported in Scala through calss =scala.util.DynamicVariable=.
#+begin_src scala
object Signal {
  private var caller = new DynamicVariable[Signal[_]](NoSignal)
  ...
}
#+end_src
*** Another Solution: Implicit Parameters
Thread-local state still comes with a number of disadvantages:
- Its imperative nature often produces hidden dependencies which are hard to manage
- Its implementation on the JDK involves a global hash table lookup, which can be a performance problem
- It does not play well in situations where threads are multiplexed between several tasks.
A cleaner solution involves implicit parameters
- Instead of maintaining a thread-local variable, pass its current value into a signal expression as an implicit parameter.
- This is purely functional. But it currently requires more boilerplate than the thread-local soluiton
- Future versions of Scala might solve that problem
*** Summary
We only covered Discrete signals changed by events.

Some variants of FRP also treat continous signals.

Value in these systems are often computed by sampling instead of event propagation.
* Week 3
** Monads and Effect
Disclamer: here "monda" in the following lectures mean a generic type with a constructor and a =flatMap= operator.

In particular, we'll be fast and loose about the monad laws(that is, we completely ignore them).
- The Four Essential Effects in Programming
|            | One     | Many        |
|------------+---------+-------------+
|Synchronous |T/Try[T] |Iterable[T]  |
|Asynchronous|Future[T]|Observalbe[T]|

Try[T]: A monad that handles exceptions.

#+begin_src scala
val adventrue = Adventrue()

val treasure: Try[Treasure] = for {
  coins    <- adventrue.collectCoins()
  treasure <- buyTreasure(coins)
} yield treasure
#+end_src
** Latency as an Effect
Future[T]: A monad that handles exceptions and latency.
- Futures asynchronously notify consumers
#+begin_src scala
import scala.concurrent._
import scala.concurrent.ExecutionContext.Implicits.global

trait Future[T] {
  def onComplete(callback: Try[T] => Unit)
    (implicit executor: ExecutionContext): Unit
}
#+end_src
** Combinators of Futures
#+begin_src scala
val pocket = Socket()
val packet: Future[Array[Byte]] =
  socket.readFromMemory()

val confirmation: Future[Array[Byte]] =
  packet.flatMap(p => socket.sendToEurope(p))
#+end_src
*** Send packets using futures robustly
#+begin_src scala
def recover(f: PartialFunction[Throwable, T]): Future[T]

def recoverWith(f: PartialFunction[Throwable, Future[T]]): Future[T]
#+end_src
*** Better recovery with less matching
#+begin_src scala
def sentToSafe(packet: Array[Byte]): Future[Array[Byte]] =
  sendTo(mailServer.europe, packet) fallbackTo {
    sendTo(mailServer.usa, packet)
  } recover {
    case europeError => europeError.getMessage.toByteArray
}
/*
... if this future fails take the successful result
  of that future ...
... if that future fails too, take the error of this future ...
*/
def fallbackTo(that: =>Future[T]): Future[T] = {
  this recoverWith {
    case _ => that recoverWith { case _ => this }
  }
}
#+end_src
*** Asynchronous where possible, blocking where necessary
#+begin_src scala
trait Awaitable[T] extends AnyRef {
  abstract def ready(atMost: Duration): Unit
  abstract def result(atMost: Duration): T
}

val c = Await.result(confirmation, 2 seconds)
println(c.toText)
#+end_src
*** Duration
#+begin_src scala
import scala.language.postfixOps

object Duration {
  def apply(length: Long, unit: TimeUnit): Duration
}

val fiveYears = 1826 minutes
#+end_src
** Composing Futures
- Retrying to send
#+begin_src scala
def retry(noTimes: Int)(block: =>Future[T]): Future[T] = {
    
} 
#+end_src
- Avoid Recursion
#+begin_src scala
def retry(noTimes: Int)(block: => Future[T]): Future[T] = {
  val ns = (1 to noTimes).toList
  val attempts = ns.map(_ => ()=>block)
  val failed = Future.failed(new Exception("boom"))
  val result = attempts.foldLeft(failed)
    ((a, block) => a recoverWith { block() })
  result 
}

retry(3) { block }
#+end_src 
** Async await
- Making effects implicit
- Async await magic
#+begin_src scala
import scala.async.Async._

def async[T](body: => T)
(implicit context: ExecutionContext): Future[T]

def await[T](future: Future[T]): T

async{ ... await{...} ...}
#+end_src
- Async, the small print
*illegal Uses*
  - The following uses of await are illegal and are reported as errors:
    - await requires a directly-enclosing async; this means await must not be used inside a closure nested within an async block, or inside a nested boject, tait, or class.
    - await must not be used inside an expression passed as an argument to a by-name parameter.
    - await must not be used inside a Boolean short-circuit argument.
    - return expressions are illegal inside an async block.
    - await should not be used under a try/catch.
- Retrying to send using await (an no recursion)
#+begin_src scala
def retry(noTimes: Int)(block: => Future[T]): Future[T] = async {
  var i = 0;
  var result: Try[T] = Failure(new Exception("..."))
  while (result.isFailure && i < noTimes) {
    result = await { Try(block) }
    i += 1
  }
  result.get
}

object Try {
  def apply(f: Future[T]): Future[Try[T]] = {...}
}
#+end_src
- Reimplementing filter using await
#+begin_src scala
def filter([p: T => Boolean): Future[T] = async {
  val x = await { this }
  if (!p(x)) {
    throw new NoSuchElementException()
  } else {
    x
  }
}
#+end_src
- Reimplementing flatMap using await
#+begin_src scala
def flatMap[S](f: T => Future[S]): Future[S] = async {
  val x: T = await { this }
  await { f(x) }
}
#+end_src
- Reimplementing filter without await
#+begin_src scala
def filter(pred: T => Boolean): Future[T] = {
  val p = Promise()
  
  this onComplete {
    case Failure(e) =>
      p.failure(e)
    case Success(x) =>
      if (!pred(x)) p.failure(new NoSuchElementException)
      else p.success(x)
  
  p.future
}
#+end_src
*** Promises, promises, promises
#+begin_src scala
trait Promise[T] {
  def future: Future[T]
  def complete(result: Try[T]): Unit
  def tryComplete(result: Try[T]): Boolean
}
#+end_src
* Week 4
** From Try to Future
** From Iterables to Observables
- Synchronous Data Streams: Iterable[T]
#+begin_src scala
while(hasNext) next()
#+end_src
- The return of the magic dualization trick
#+begin_src scala
type Iterator[T] =
  () => Option[T]

type Iterable[T] =
  () => (() => Try[Option[T]])

trait Observer[T] {
  def onNext(T value): Unit
  def onError(Throwable error): Unit
  def onCompleted(): Unit
}

trait Observable[T] {
  def Subscribe(observer: Observer[T]): Subscription
}

trait Subscription {
  def unsubscribe(): Unit
  def isUnsubscribed: Boolean
}
#+end_src
- Hello World Observale
#+begin_src scala
val tricks: Observable[Long] = Observale.interval(1 seconds)
val events: Observable[Long] = tricks.filter(_%2==0)
val bufs: Observable[Seq[Long]] = evens.slidingBuffer(count = 2, skip = 1)
val s = bufs.subscribe(println(_))
s.unsubscribe()
#+end_src
- Rx Operators
- Subscriptions
Cold Observable \approx each subscriber has its own private source (subscription causes side effect)
Hot Observable \approx same source shared by all subscribers
  - CompositeSubscription
  - MultiAssignmentSubscription
  - SerialSubscription
** Promises and Subjects
- Subject[T]
#+begin_src scala
onNext(value: T)
onCompleted()
onError(e: Throwable)

subscribe(o: Observer[T])
#+end_src
- Example: Subjects are like channels
#+begin_src scala
val channel = ReplaySubject[Int]()

val a = channel.subscribe(x => println(s"a: $x"))
val b = channel.subscribe(x => println(s"b: $x"))

channel.onNext(42)
a.unsubscribe()

channel.onNext(4711)
channel.onCompleted()

val c = channel.subscribe(x => println(s"c: $x"))
channel.onNext(13)
#+end_src scala
- Subjects: meet the family
#+begin_src scala
async subject    // caches final value
publish subject  // current value
replay subject   // caches all values
behavior subject // caches latest value
#+end_src
- You don't need Subjects in most cases
Subjects are like mutable var
** Rx Potpourri
- Converting Future[T] to Observable[T]
#+begin_src scala
object Observable {
  def apply[T](f: Future[T]): Observable[T] = {
    val subject = AsyncSubject[T]()
    f.onComplete {
      case Failure(e) => { subject.onError(e) }
      case Success(t) => {
        subject.onNext(t)
        subject.onCompleted()
      }
    }
    subject
  }
}
#+end_src
- Observable notifications
#+begin_src scala
abstract class Try[+T]
case class Success[T](elem: T) extends Try[T]
case class Failure(t: Throwable) extends Try[Nothing]

abstract class Notification[+T]
case class OnNext[T](elem: T) extends Notification[T]
case class OnError(t: Throwable) extends Notification[Nothing]
case object OnCompleted extends Notification[Nothing]

def materialize: Observable[Notification[T]] = {...}
#+end_src
- Remember blocking
#+begin_src scala
val f: Future[T] = Future {...}
val t: T = Await.result(f, 10 seconds)

val o: Observable[T] = Observable(...)
val ts: Observable[T] = o.toBlocking
ts.forEach(t => {...})
#+end_src
- Blocking
#+begin_src scala
val xs: Observable[Long] = Observable.interval(1 second).take(5)
val ys: List[Long] = xs.toBlocking.toList
println(ys)

val zs: Observable[Long] = xs.sum
val s: Long = zs.toBlocking.single
#+end_src
- Converting Observables to scalar types
#+begin_src scala
def reduce(f: (T, T) => T): Observable[T]
#+end_src
- Creating Observables
#+begin_src scala
object Observable {
  def apply[T](subscribe: Subscriber[T] => Unit): Observable[T]
}

import scala.util.control.Breaks._

def from[T](ts: Iterable[T]): Observable[T] = Observable(s => {
  ts.foreach(t => {
    if(s.isUnsubscribed) { break }
    s.onNext(t)
  })
  s.onCompleted()
})
#+end_src
- Backpressure
check it in Rx wiki
** Observable Contract
- Auto-unsubscribe
#+begin_src scala

#+end_src
Rx Contract: (onNext)*(onCompleted+onError)
- Rx Contract
/Rx Design Guidelines/

* Week 5
** What is an Actor?
The Actor Model represents objects and their interactions, resembling human organizations and built upon the laws of physics.

An Actor
  - is an object with identity
  - has a behavior
  - only interacts using asynchronous message passing
- The Actor Trait
#+begin_src scala
type Receive = PartialFunction[Any, Unit]

trait Actor {
  def receive: Receive
  ...
}
#+end_src
The Actor type describes the behavior of an Actor, its response to messages.
- A Simple Actor
#+begin_src scala
class Counter extends Actor {
  var count = 0
  def receive = {
    case "incr" => count += 1
  }
}
#+end_src
This object does not exhibit stateful behavior.
- Making it Stateful
Actors can send message to address (ActorRef) they know:
#+begin_src scala
class Counter extends Actor {
  var count = 0
  def receive = {
    case "incr" => count += 1
    case ("get", customer: ActorRef) => customer ! count
  }
}
#+end_src
- How Message are Sent
#+begin_src scala
trait Actor {
  implicit val self: ActorRef
  def sender: ActorRef
  ...
}

abstract class ActorRef {
  def !(msg: Any)(implicit sender: ActorRef = Actor.noSender): Unit
  def tell(msg: Any, sender: ActorRef) = this.!(msg)(sender)
  ...
}
#+end_src
- Using the Sender
#+begin_src scala
class Counter extends Actor {
  var count = 0
  def receive = {
    case "incr" => count += 1
    case "get" => sender ! count
  }
}
#+end_src
- The Actor's Context
The Actor type describes the behavior, the execution is done by its ActorContext.
#+begin_src scala
trait ActorContext {
  def become(behavior: Receive, discardOld: Boolean = true): Unit
  def unbecome(): Unit
  ...
}

trait Actor {
  implicit val context: ActorContext
  ...
}
#+end_src
- Changing an Actor's Behavior
#+begin_src scala
class Counter extends Actor {
  def counter(n: Int): Receive = {
    case "incr" => context.become(counter(n+1))
    case "get" => sender ! n
   }
   def receive = counter(0)
}
#+end_src
Functionally equivalent to previous version, with advantages
  - state change is explicit
  - state is scoped to current behavior
Similar to "asynchronous tail-recursion".
- Creating and Stopping Actors
#+begin_src scala
trait ActorContext {
  def actorOf(p: Props, name: String): ActorRef
  def stop(a: ActorRef): Unit
  ...
}
#+end_src
Actors are created by actors.

"stop" is often applied to "self".
** Message Processing Semantics
- Actor Encapsulation
No direct access is possible to the actor behavior.

Only messages can be sent to known addresses (ActorRef).
  - every actor knows its own address (self)
  - creating an actor returns its address
  - addresses can be sent within message (e.g. sender)
Actors are completely independent agent of computation:
  - local execution, no notion of global synchronization
  - all actors run fully concurrently
  - message-passing primitive is one-way communication
- Actor-Internal Evaluation Order
An actor is effectively single-threaded:
  - messages are received sequentially
  - behavior change is effective before processing the next message
  - processing one message is the atomic unit of execution
This has the benefits of synchronized methods, but blocking is replaced by enqueueing a message.
- Actor Collaboration
- Message Delivery Guarantees
  - all communication is inherently unreliable
  - delivery of a message requires eventual availability of channel & recipient
at-most-once
at-least-once
exactly-once
- Reliable Messaging
  - all message can be persisted
  - can include unique correlation IDs
  - delivery can be retries until successful
Reliability can only be ensured by business-level acknowledgement.
- Message Ordering
If an actor sends multiple messages to the same destination, they will not arrive out of order (this is Akka-specific).

** Designing Actor Systems
*** Starting Out with the Design
Imaging giving the task to a group of people, dividing it up.

Consider the group to be of very large size.

Start with how people with different tasks will take with each other.

Consider these "people" to be easily replaceable.

Draw a diagram with how the task will be split up, including communication lines.
*** Example: the Link Checker
Write an actor system whitch given a URL will recursively download the content, exteact links and follow them, bounded by a maximum depth; all links encountered shall be returned.
*** Plan of Action
- Write web client which turns a URL into a HTTP body asynchronously.
  We will be using "com.ning" % "async-http-client" % "1.7.19"
- Write a Getter actor for processing the body.
- Write a Controller which spawns Getters for all links encountered.
- Write a Receptionist managing one Contoller per request.
*** The Web Client (1)
Let's start simple:
#+begin_src scala
val client = new AsyncHttpClient
def get(url: String): String = {
  val response = client.prepareGet(url).execute().get
  if (response.getStatusCode < 400)
    response.getResponseBodyExcerpt(131072)
  else throw BadStatus(response.getStatusCode)
}
#+end_src
Blocks the calling actor until the web server has replied:
  - actor is deaf to other requests, e.g. cancellation does not work
  - wastes one thread -- a finite resource
#+begin_src scala
private val client = new AsyncHttpClient
def get(url: String) (implicit exec: Executor): Future[String] = {
  val f = client.prepareGet(url).execute();
  val p = Promise[String]()
  f.addListener(new Runnable {
    def run = {
      val response = f.get
      if (response.getStatusCode < 400)
        p.success(response.getResponseBodyExcerpt(131072))
      else
        p.failure(BadStatus(response.getStatusCode))
    }
  }, exec)
  p.future
}
#+end_src
*** Finding Links
#+begin_src scala
// using "org.jsoup" % "jsoup" % "1.8.1"
import org.jsoup.Jsoup
import scala.collection.JavaConverters._

def findLinks(body: String): Iterator[String] = {
  val document = Jsoup.parse(body, url)
  val links = document.select("a[href]")
  for {
    link <- links.iterator().asScala
   } yield link.absUrl("href")
}
#+end_src
- The Getter Actor (1)
#+begin_src scala
class Getter(url: String, depth: Int) extends Actor {
  implicit val exec = context.dispatcher

  val future = WebClient.get(url)
  future onComplete {
    case Success(body) => self ! body
    case Failure(err) => self ! Status.Failure(err)
  }
  ...
}
#+end_src
- The Getter Actor (2)
Akka has a pattern for the above code.
#+begin_src scala
class Getter(url: String, depth: Int) extends Actor {
  implicit val exec = context.dispatcher

  val future = WebClient.get(url)
  future.pipeTo(self)
  ...
}
#+end_src
- The Getter Actor (3)
#+begin_src scala
class Getter(url: String, depth: Int) extends Actor {
  implicit val exec = context.dispatcher

  WebClient get url pipeTo self
  ...
#+end_src
- The Getter Actor (4)
#+begin_src scala
class Getter(url: String, depth: Int) extends Actor {
  ...
  def receive = {
    case body: String =>
      for (link <- findLinks(body))
        context.parent ! Controller.Check(link, depth)
      stop()
    case _: Status.Failure => stop()
  }
  def stop(): Unit = {
    context.parent ! Done
    context.stop(self)
  }
}
#+end_src
*** Actor-Based Logging
- Logging includes IO which can block indefinitely
- Akka's logging passes that task to dedicated actors
- supports ActorSystem-wide levels of =debug, info, waring, error=
- set level using setting akka.loglevel=DEBUG (for example)
#+begin_src scala
class A extends Actor with ActorLogging {
  def receive = {
    case msg => log.debug("received message: {}", msg)
  }
}
#+end_src
*** The Controller
#+begin_src scala
class Controller extends Actor with ActorLogging {
  var cache = Set.empty[String]
  var childeren = Set.empty[ActorRef]
  def receive = {
    case Check(url, depth) =>
      log.debug("{} checking {}", depth, url)
      if (!cache(url) && depth > 0)
        children += context.actorOf(Props(new Getter(url, depth + 1)))
      cache += url
    case Getter.Done =>
      children -= sender
      if (children.isEmpty) context.parent ! Result(cache)
  }
}
#+end_src
*** Handling Timeouts
#+begin_src scala
import scala.concurrent.duration._

class Controller extends Actor with ActorLogging {
  context.setReceiveTimeout(10.seconds)
  ...
  def receive = {
    case Check(...)  => ...
    case Getter.Done => ...
    case ReceiveTimeout => children.foreach (_ ! Getter.Abort)
  }
}
#+end_src
The receive timeout is reset by every received message.
*** The Scheduler
Akka includes a timer service optimized for high volume, short durations and frequent cancellation.
#+begin_src scala
trait Scheduler {
  def scheduleOnce(delay: FiniteDuration, target: ActorRef, msg: Any)
                  (implicit ec: ExecutionContext): Cancellable

  def scheduleOnce(delay: FiniteDuration)(block: => Unit)
                  (implicit ec: ExecutionContext): Cancellable

  def scheduleOnce(delay: FiniteDuration, run: Runnable)
                  (implicit ec: ExecutionContext): Cancellable
  ... // the same for repeating timers
}
#+end_src
*** Adding an Overall Timeout (1)
#+begin_src scala
class Controller extends Actor with ActorLogging {
  import context.dispatcher
  var childeren = Set.empty[ActorRef]
  context.system.scheduler.scheduleOnce(10.secnonds) {
    children foreach (_ ! Getter.Abort)  // #1
  } ... }
#+end_src
Not thread-safe, since #1 runs in scheduler not actor context.
*** Adding an Overall Timeout (2)
#+begin_src scala
class Controller extends Actor with ActorLogging {
  import context.dispatcher
  var childeren = Set.empty[ActorRef]
  context.system.scheduler.scheduleOnce(10.secnonds, self, Timeout)
  ...
  def receive = {
    ...
    case Timeout => children foreach (_ ! Getter.Abort)
  }
}
#+end_src
*** How Actors and Future Interact (1)
#+begin_src scala
class Cache extends Actor {
  var cache = Map.empty[String, String]
  def receive = {
    case Get(url) =>
      if (cache contains url) sender ! cache(url)
      else
        WebClient get url foreach { body =>
          cache += url -> body
          sender ! body
        }
  }
}
#+end_src
*** How Actors and Future Interact (2)
#+begin_src scala
class Cache extends Actor {
  var cache = Map.empty[String, String]
  def receive = {
    case Get(url) =>
      if (cache contains url) sender ! cache(url)
      else
        WebClient get url map (Result(sender, url, _)) pipeTo self
    case Result(client, url, body) =>
      cache += url -> body
      client ! body
  }
}
#+end_src
*** How Actors and Future Interact (3)
#+begin_src scala
class Cache extends Actor {
  var cache = Map.empty[String, String]
  def receive = {
    case Get(url) =>
      if (cache contains url) sender ! cache(url)
      else {
        var client = sender  // cache the sender
        WebClient get url map (Result(client, url, _)) pipeTo self
      }
    case Result(client, url, body) =>
      cache += url -> body
      client ! body
  }
}
#+end_src
*** The Receptionist (1)
#+begin_src scala
class Receptionist extends Actor {
  def receive = waiting

  val waiting: Receive = {
    // upon Get(url) start a traversal and become running
    case Get(url) => context.become(runNext(Vector(Job(sender, url))))
  }
  
  def running(queue: Vector[Job]): Receive = {
    // upon Get(url) append that to queue and keep running
    // upon Contoller.Result(links) ship that to client
    //   and run next job from queue (if any)
    case Controller.Result(links) =>
      val job = queue.head
      job.client ! Result(job.url, links)
      context.stop(sender)
      context.become(runNext(queue.tail))
    case Get(url) =>
      context.become(enqueueJob(queue, Job(sender, url)))
  }

  def enqueueJob(queue: Vector[Job], job: Job): Receive = {
    if (queue.size > 3) {
      sender ! Failed(job.url)
      running(queue)
    } else running(queue :+ job)
  }
}
#+end_src
*** The Receptionist (2)
#+begin_src scala
case class Job(client: ActorRef, url: String)
var reqNo = 0
def runNext(queue: Vector[Job]): Receive = {
  reqNo += 1
  if (queue.isEmpty) waiting
  else {
    val controller = context.actorOf(Props[Controller], s"c$reqNo")
    controller ! Controller.Check(queue.head.url, 2)
    running(queue)
  }
}
#+end_src
=reqNo= permeates all state but does not qualitatively change behavior: an example for when using =var= may benefit.
*** What we learned so far
- A reactive application is non-blocking & event-driven top to bottom.
- Actors are run by a dispatcher -- potentially shared -- which can also run Futures.
- Prefer immutable data structures, since they can be shared.
- Do not refere to actor state from code running asynchronously
** Testing Actor Systems
*** Testing Actors
Tests can only verify externally observable effects
*** Akka's TestKit (1)
TestProbe as remote-controlled actor.
#+begin_src scala
implicit val system = ActorSystem("TestSys")
val toggle = system.actorOf(Props[Toggle])
val p = TestProbe()
p.send(toggle, "How are you?")
p.expectMsg("happy")
p.send(toggle, "How are you?")
p.expectMsg("sad")
p.send(toggle, "unknow")
p.expectNoMsg(1.second)
system.shutdown()
#+end_src
*** Akka's TestKit (2)
Running a test within a TestProbe:
#+begin_src scala
new TestKit(ActorSystem("TestSys")) with ImplicitSender {
  val toggle = system.actorOf(Props[Toggle])
  toggle ! "How are you?"
  expectMsg("happy")
  toggle ! "How are you?"
  expectMsg("sad")
  toggle ! "unknown"
  expectNoMsg(1.second)
  system.shutdown()
}
#+end_src
*** Testing Actors with Dependencies
Accessing the real DB or production web services is not desirable:
  - Akka + Spring
  - one simple solution is to add overridable factory methods
#+begin_src scala

#+end_src
*** Testing Interaction with the Parent
Create a step-parent:
#+begin_src scala

#+end_src
*** Inserting a Foster-Parent
#+begin_src scala

#+end_src
*** Testing Actor Hierarchies
Start verifying leaves, work your way up:
  - "Reverse Onion Testing"
* Week 6
** Failure Handling with Actors
*** Failure Handling in Asynchronous Systems
Where shall failures go?
  - reify as messages
  - send to a known address
The Actor Model is anthropomorphic:
  - Actors work together in teams (systems)
  - individual failure is handled by the team leader
*** Supervision
Resilience demands /containment/ and /delegation/ of failure.
  - failed Actor is terminated or restarted
  - decision must be taken by one other Actor
  - supervised Actors form a tree structure
  - the supervisor needs to create its subordinate
*** Supervisor Strategy
In Akka the parent declares how its child Actors are supervised:
#+begin_src scala
class Manager extends Actor {
  override val supervisorStrategy = OneForOneStrategy() {
    case _: DBException => Restart // reconnect to DB
    case _: ActorKilledException => stop
    case _: ServiceDownException => Escalate
  }
  ...
  context.actorOf(Props[DBActor], "db")
  context.actorOf(Props[ImportantServiceActor], "service")
  ...
}
#+end_src
Failure is sent and processed like a message:
#+begin_src scala
class Manager extends Actor {
  var restarts = Map.empty[ActorRef, Int].withDefaultValue(0)
  override val supervisorStrategy = OneForOneStrategy() {
    case _: DBException =>
      restarts(sender) match {
        case toomany if toomany  > 10 =>
        case n =>
          restarts = restarts.updated(sender, n + 1); Restart
      }
  }
}
#+end_src
If decision applies to all children: =AllForOneStrategy=

Simple rate trigger included:
  - allow a finite number of restarts
  - allow a finite number of restarts in a time window
  - if restriction violated then =Stop= instead of =Restart=
#+begin_src scala
OneForOneStrategy(maxNrOfRestarts = 10, withinTimeRange = 1.minute) {
  case _: DBException => Restart // will turn into Stop
}
#+end_src
*** Actor Identity
Recovery by restart requires stable identifier to refer to the service:
  - in Akka the ActorRef stays valid after a restart
  - in Erlang a name is registered for the current PID
What does restart mean?
  - expected error conditions are handled explicitly
  - unexpected error indicate invalidated actor state
  - restart will install initial behavior / state
*** Actor Lifecycle
- start
- (restart)*
- stop
*** Actor Lifecycle Hooks
#+begin_src scala
trait Actor {
  def preStart(): Unit = {}
  def preRestart(reason: Throwable, message: Option[Any]): Unit = {
    context.children foreach (context.stop(_))
    postStop()
  }
  def postRestart(reason: Throwable): Unit = {
    preStart()
  }
  def postStop(): Unit = {}
  ...
}
#+end_src
*** The Default Lifecycle
#+begin_src scala
class DBActor extends Actor {
  val db = DB.openConnection(...)
  ...
  override def postStop(): Unit = {
    db.close()
  }
}
#+end_src
In this model the actor is fully reinitialized during restart.
*** Lifecycle Spanning Restarts
#+begin_src scala
class Listener(source: ActorRef) extends Actor {
  override def preStart() { source ! RegisterListener(self) }
  override def preRestart(reason: Throwable, message: Option[Any]) {}
  override def postRestart(reason: Throwable) {]
  override def postStop() { source ! UnregisterListener(self) }
}
#+end_src
Actor-local state cannot be kept across restarts, only external state can be managed like this.

Child actors not stopped during restart will be restarted recursively.
** Lifecycle Monitoring and the Error Kernel
*** Lifecycle Monitoring
The only observable transition occurs when stopping an actor:
  - having an =ActorRef= implies liveness (at some earlier point)
  - restarts are not externally visible
  - after stop there will be no more responses
No replies could also be due to communication failure, therefore Akka supports Lifecycle Monitoring a.k.a. DeathWatch.
  - an =Actor= registers its interest using =context.watch(target)=
  - it will receive a =Terminated(target)= message when target stops
  - it will not receive any direct messages from target thereafter
*** The DeathWatch API
#+begin_src scala
trait ActorContext {
  def watch(target: ActorRef): ActorRef
  def unwatch(target: ActorRef): ActorRef
  ...
}

case class Terminated private[akka] (actor: ActorRef)
  (val existenceConfired: Boolean, val addressTerminated: Boolean)
    extends AutoReceiveMessage with PossiblyHarmful
#+end_src
*** The Children List
Each =actor= maintains a list of the =actors= it created:
  - the =child= has been entered when =context.actorOf= returns
  - the =child= has been removed when =Terminated= is received
  - an =actor= name is available IFF there is no such =child=
#+begin_src scala
trait ActorContext {
  def children: Iterable[ActorRef]
  def child(name: String): Option[ActorRef]
  ...
}
#+end_src
*** Applying DeathWatch to Contoller & Getter
#+begin_src scala
class Controller extends Actor with ActorLogging {
  override val supervisorStrategy = OneForOneStrategy(maxNrOfRetries = 5) {
    case _: Exception => SupervisorStrategy.Restart
  }
  def receive = {
    case Check(url, depth) =>
      if (!cache(url) && depth > 0)
        context.watch(context.actorOf(getterProps(url, depth - 1)))
      cache += url
    case Terminated(_) =>
      if (context.children.isEmpty) context.parent ! Result(cache)
    case ReceiveTimeout => context.children foreach context.stop
  }
  ...
}
#+end_src
*** The Error Kernel
Keep important data near the root, delegate risk to the leaves.
  - restarts are recursive (supervised actors are part of the state)
  - restarts are more frequent near the leaves
  - avoid restarting Actors with important state
*** Application to Receptionist
  - Always stop Contoller if it has a problem.
  - React to =Terminated= to catch cases where =no Result= was sent.
  - Discard =Terminated= after =Result= was sent.
#+begin_src scala
class Receptionist extends Actor {
  override def supervisorStrategy = SupervisorStrategy.stoppingStrategy
  ...
}
#+end_src
*** Interjection: the EventStream
Actors can direct messages only at known address.

The EventStream allows publication of messages to an unknown audience.

Every actor can optionally subscribe to (parts of) the EventStream.
#+begin_src scala
trait EventStream {
  def subscribe(subscriber: ActorRef, topic: Class[_]): Boolean
  def unsubscribe(subscriber: ActorRef, topic: Class[_]): Boolean
  def unsubscribe(subscriber: ActorRef): Unit
  def publish(event: AnyRef): Unit
}

class Listener extends Actor {
  context.system.eventStream.subscribe(self, classOf[LogEvent])
  def receive = {
    case e: LogEvent => ...
  }
  override def postStop(): Unit = {
    context.system.eventStream.unsubscribe(self)
  }
}
#+end_src
*** Where do Unhandled Messages Go?
=Actor.Receive= is a partial function, the behavior may not apply.

=Unhandled= messages are passed into the =unhandled= method:
#+begin_src scala
trait Actor {
  ...
  def unhandled(message: Any): Unit = message match {
    case Terminated(target) => throw new DeathPactException(target)
    case msg =>
      context.system.eventStream.publish(UnhandledMessage(msg, sender, self))
  }
}
#+end_src
** Persistent Actor State
Actors representing a stateful resource
  - shall not lose important state due to (system) failure
  - must persist state as needed
  - must recover state at (re)start
Two possibilities for persisting state:
  - in-place updates
  - persist changes in append-only fashion
*** Changes vs. Current State
*** Snapshots
Immutable snapshots can be used to bound recovery time
*** Persistence Primitive
  - being persistent means "taking notes"
#+begin_src scala
persist(MyEvent(...)) { event =>
  // now <event> is persisted
  do SomethingWidth(event)
}
#+end_src
*** Event Example
#+begin_src scala
case class NewPost(text: String, id: Long)
case class BlogPosted(id: Long)
case class BlogNotPosted(id: Long, reason: String)

sealed trait Event
case class PostCreated(text: String) extends Event
case object QuotaReached extends Event

case class State(posts: Vector[String], disabled: Boolean) {
  def updated(e: Event): State = e match {
    case PostCreated(text) => copy(posts = posts :+ text)
    case QuotaReached      => copy(disabled = true)
  }
}

class UserProcessor extends PersistentActor {
  var state = State(Vector.empty, false)
  def receiveCommand = {
    case NewPost(text, id) =>
      if (state.disabled) sender() ! BlogNotPosted(id, "quota reached")
      else { persist(PostCreated（text)) { e =>
                 updateState(e)
                 sender() ! BlogPosted(id) }
             persist(QuotaReached) (updateState) }
 }
  def updateState(e: Event) { state = state.updated(e) }
  def receiveRecover = { case e: Event => updateState(e) }
}  

case NewPost(text, id) =>
  if (!state.disabled) {
    val created = PostCreated(text)
    update(created)
    update(QuotaReached)
    persistAsync(created)(sender() ! BlogPosted(id))
    persistAsync(QuotaReached)(_ => ())
  } else sender() ! BlogNotPosted(id, "quota reached")
#+end_src
*** When to Apply the Events?
- Applying after persisting leaves actor in stale state.
*** At-Least-Once Delivery
  - Guaranteeing delivery means retrying until successful
  - Retries are the sender's responsibility
  - The recipient needs to acknowledge receipt
  - Lost receipts lead to duplicate deliveries => at-least-once
------  
  - Retrying means taking note that the message needs to be sent
  - Acknowledgement means taking note of the receipt of the confirmation
#+begin_src scala
class UserProcessor 
    extends PersistentActor with AtLeastOnceDelivery {
  def receiveCommand = {
    case NewPost(text, id) =>
      persist(PostCreated(text)) { e =>
        deliver(publisher, PublishPost(text, _))
        sender() ! BlogPosted(id) }
    case PostPublished(id) => confirmDelivery(id)
  }
  def receiveRecover = {
    case PostCreated(text) => deliver(publisher, PublishPost(text, _))
    case PostPublished(id) => confirmDelivery(id)
  }
} 
#+end_src
*** Exactly-Once Delivery
- /At-least-Once/ delivery leads to duplicates at the receiver
- The receiver needs to remember what it has already done to avoid redoing it
#+begin_src scala
class Publisher extends PersistentActor {
  var expectedId = 0L
  def receiveCommand = {
    case PublishPost(text, id) =>
      if (id > expectedId) () // ignore, not yet ready for that
      else if (id < expectedId) sender() ! PostPublished(id)
      else persist(PostPublished(id)) { e =>
          sender() ! e
          // modify website
          expectedId += 1
      }
  }
  def receiveRecover = { case PostPublished(id) => expectedId = id + 1 }
}
#+end_src
*** When to Perform External Effects?
Performing the effect and persisting that it was done cannot be atomic.
  - Perform it before persisting for at-least-once semantics.
  - Perform it after persisting for at-most-once semantics.
This choice needs to be made based on the underlying business model.

If processing is /idempotent/ then using at-least-once semantics achieves /effectively exactly-once processing./
*** Summary
- Actors persist facts that represent changes to their state.
- Events can be replicated and used to inform other components.
- Recovery replays past events to reconstruct state; snapshots reduce this cost.
* Week 7
** Actors are Distributed

